webpackJsonp([0],{783:function(n,e,t){var o=t(15),r=t(45),s=t(289).PageRenderer;s.__esModule&&(s=s.default);var a=r({displayName:"WrappedPageRenderer",getInitialState:function(){return{content:t(784)}},componentWillMount:function(){},render:function(){return o.createElement(s,Object.assign({},this.props,{content:this.state.content}))}});a.__catalog_loader__=!0,n.exports=a},784:function(n,e){n.exports="# react-high-order\n\nA set of higher order and render props components that will help increasing your productivity on web development.\n\n```\nnpm install --save react-high-order\n```\n\n## Why react-high-order exists ?\n\nIn my opinion, React is the best tools for creating modular components that can be combined to something bigger and more complex\n (or maybe because I never use any other front-end library or framework). However, the more you code the more you will ask yourself, \n \"why I have to rewrite the same component or the save behavior for every new project ?\". I think it is time for me to create\n real world reusable react components that contain some logic inside such as a component that can call api and provide status to children,\n a component that can collect a function and will be called when user click submit. Let's get started\n \n## Example\n\nWhen you want to create a component that contain simple api calling inside a component you would do this\n```js\n    const api = () => new Promise((resolve) => {\n      resolve('response from api');\n    });\n    \n    class Example extends React.Component {\n    \n      static propTypes = {};\n    \n      state = {\n        status: 'initialized',\n        error: null,\n        response: null\n      };\n    \n      callApi = () => {\n        this.setState({ status: 'requesting' });\n        api()\n          .then((response) => this.setState({\n            response,\n            status: 'success'\n          }))\n          .catch((error) => this.setState({\n            error,\n            status: 'failure'\n          }));\n      };\n    \n      render() {\n        const { status, response, error } = this.state;\n        return (\n          <div>\n            <p>{status}</p>\n            {response && (\n              <p>\n                {/* or render something else */}\n                {response}\n              </p>\n            )}\n            {error && (\n              <p>{error}</p>\n            )}\n            <button onClick={this.callApi}>\n              {status === 'requesting' ? 'Requesting...' : 'Call API'}\n            </button>\n          </div>\n        );\n      }\n    }\n```\n\nBut with react-high-order, you only have to do this\n```js\n    import { Caller } from 'react-high-order'\n    \n    const Example = () => (\n      <Caller api={api}>\n        {(wrappedApi, { status, response, error, reset }) => {\n          return (\n            <div>\n              <p>\n                {status.isInitial && 'Initialized'}\n                {status.isRequest && 'Requesting'}\n                {status.isSuccess && 'Success'}\n                {status.isFailure && 'Failed!'}\n              </p>\n              <p>{response}</p>\n              {error && (\n                <button onClick={reset}>reset</button>\n              )}\n              <button onClick={wrappedApi}>\n                {status === 'requesting' ? 'Requesting...' : 'Call API'}\n              </button>\n            </div>\n          );\n        }}\n      </Caller>\n    )\n```\nWhat Caller do is just wrapping the api you provide with status and then transfer to its children.\nThis technique is officially called as [render props](https://reactjs.org/docs/render-props.html).\nThe code is more cleaner and declarative, you don't have to be overwhelmed with lots of state.\n\n## API\n\nMostly react-high-order components will be hoc or using render props technique. The purpose of this repo\nis to help you increase your productivity in web development without messing core logic in your app.\n\n### TOC\n\n* Render props\n    + [`Caller`](#caller)\n    + [`Collector`](#collector)\n    \n    \n## Render Props\n### `Caller`\n**`description`** : accept child only as a function and provide wrappedApi, status, ...others to it.\n \n**`use case`** : Call api within component\n\n**`parameters`** \n\n| props             | type                  | default   |\n| -------------     |-------------          | -----     |\n| children (*)      | fn(options) => react element   | -         |\n| api (*)           | fn => promise         | -         |\n| onRequest         | fn => void            | () => {}  |\n| onSuccess         | fn => void            | () => {}  |\n| onFailure         | fn => void            | () => {}  |\n\n**`children options`**\n\n| parameters             | type                  | initial state   | description |\n| -------------     |-------------          | -----     | --- |\n| wrappedApi         | fn           | -  | the same fn as api from props but wrapped with status\n| status          | object         | null         | `{ state:<String: 'isInitial', 'isSuccess', 'isFailure'>, isInitial:<Bool>, isRequest:<Bool>, isSuccess:<Bool>, isFailure:<Bool> }`\n| response         | -           | null  | resolve from api\n| error         | -            | null  | reject from api\n| reset         | fn            | fn  | reset status, response, error to initial state | \n\n**`example`** \n```js\n  <Caller api={api}>\n    {(wrappedApi, { status, response, error, reset }) => {\n      return (\n        // You can do whatever you want\n        // show status\n        // show response\n        // show error from api\n        // even calling reset  if you want.\n      );\n    }}\n  </Caller>\n```\n\n**`Notes`** You can change state of the status by doing this\n```js\nimport { Caller } from 'react-high-order'\n\nCaller.REQUEST = 'isPending'\nCaller.SUCCESS = 'isFulfilled'\nCaller.FAILURE = 'isFailure'\n\nexport default Caller\n\n// then use Caller from above\n// the result will be like\n\nimport Caller from '../file above';\n\n<Caller>\n  {(wrappedApi, { status }) => (\n    // status = { isInitial<Bool>, isPending<Bool>, isFulfilled<Bool>, isFailure<Bool> }\n  )}\n</Caller>\n```\n\n### `Collector`\n**`description`**\naccept child only as a function and provide wrappedAction that you can called later. \n\n**`use case`**: Show modal before deleting something\n\n**`parameters`** \n\n| props             | type                  | default   |\n| -------------     |-------------          | -----     |\n| children (*)      | fn(options) => react element   | -         |\n| action (*)           | fn => (promise or void)         | -         |\n| actionIsPromise         | bool            | false |\n| resetAfterAction         | bool or object            | false  |\n\n**`children options`**\n\n| parameters             | type                  | initial state   | description |\n| -------------     |-------------          | -----     | --- |\n| wrappedAction          | fn         | -         | the same fn as action from props but wrapped to toggle activated\n| collect          | fn         | -         | set activated to true\n| reset         | fn           | -  | reset to initial state\n| activated         | bool           | false  | a boolean that tell activate sth (such as modal) \n\n**`example`**\n```js\n<Collector action={deleteApi}>\n    {(wrappedAction, { collect, reset, activated }) => (\n      <div>\n        <Modal open={activated}>\n          <button onClick={wrappedAction}>call action</button>\n          <button onClick={reset}>cancel</button>\n        </Modal>  \n        <div>\n          <button onClick={collect}>activate</button>\n        </div>\n      </div>\n    )}\n</Collector>\n```\n\n\n"}});
//# sourceMappingURL=0.ca061ffc.chunk.js.map